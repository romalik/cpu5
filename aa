text

LIT 8    -> A
LIT 2    -> B
LIT 20   -> ML
LIT 0    -> MH
LIT 1(-) -> ALUOP
ALU      -> MEM


hex

50 08
51 02
52 20
53 0
58 1
26


text

LIT 20  -> ML
LIT 0   -> MH   ; store 0x0020 to Mem Latch
LIT 10  -> A    ; store 10 to Reg A
A       -> MEM  ; store Reg A to Mem (0x0020)
A       -> SL   ; store Reg A to Reg SL
loop:           ; label to loop
MEM     -> A    ; load mem (0x0020) to Reg A
LIT 1   -> B    ; load 1 to Reg B
LIT 1   -> ALUOP (-) ; set operation to subtraction
ALU     -> MEM  ; save op result to mem (0x0020)
ALU     -> SL   ; save op result to Reg SL
ALU     -> A    ; save op result to Reg A
LIT 0   -> B    ; load 0 to reg B
LIT 61  -> ALUOP (!=)   ; set operation to subtraction,
                        ; comparison to "not equal"
                        ; we want to chech A != 0
ALU     -> A  (discard) ; do not need result, need only
                        ; comparison result (bool)
LIT loop-> A            ; load address of loop label to A
                        ; (address is guaranteed to be
                        ; less than 0x100, B is zero)
A       -> J_COND       ; if comparison true
                        ; swap program counter (16 bit)
                        ; with A and B reg (8 bit each)
                        ; here we should have jumped on
                        ; true
LIT 0   -> A            ; here we load address 0 to A
A       -> J            ; and jump unconditionally


hex

52 20
53 0
50 10
06
04
[loop:8]
30
51 1
58 1
26
24
20
51 0
58 61
20
50  [loop(8)]
0e
50 0
0f



DLIT 12 34 -> ML
LIT 10 -> A

d2 12 34
50 10



DLIT ff 0 -> SL
LIT 1 -> A
A -> ST
LIT 2 -> A
A -> ST
LIT 3 -> A
A -> ST
00 00
ST -> B
ST -> B
ST -> B


d4 fe 00
50 1
07
50 2
07
50 3
07
00 00 00
41
41
41



loop with fn call
DLIT fe 0   -> SL
DLIT 30 0   -> ML
LIT 10      -> A
A           -> MEM
loop:
DLIT [fn] -> A
A         -> J (call)
MEM     -> A
LIT 0   -> B
LIT 61  -> ALUOP (!=)
ALU     -> A  (discard)
LIT loop-> A
A       -> J_COND
LIT 0   -> A
A       -> J

fn:
B       -> ST
A       -> ST
MEM     -> A
LIT 1   -> B
LIT 1   -> ALUOP (-)
ALU     -> MEM
ALU     -> SH
LIT 0   -> SH
DST     -> A (return)
A       -> J


d4 fe 0
d2 30 0
50 10
06

[loop:0x09]
d0 [fn 0x0019]
0f
30
51 0
58 61
20
50 [loop 0x09]
0e
50 0
0f

[fn:0x0019]
17
07
30
51 1
58 1
26
25
55 0
c0
0f
